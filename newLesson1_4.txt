ในคาบที่ผ่านๆ มา เราได้เรียนรู้เกี่ยวกับ "ส่วนประกอบ" ของโลกคอมพิวเตอร์ไปแล้ว ไม่ว่าจะเป็นบิต, ไบต์, ระบบเลขฐาน และเราก็ได้ทำความรู้จักกับ "แผนการ" หรืออัลกอริทึมไปแล้ว แต่วันนี้ เราจะมาพูดถึงทักษะที่เป็น "แก่น" และเป็นตัวตัดสินว่าใครคือโปรแกรมเมอร์หรือวิศวกรที่แท้จริง ทักษะที่ว่านั้นคือ "การแก้ปัญหา" (Problem Solving) ครับ

ผมอยากให้ทุกคนลองนึกถึงความรู้สึกนี้... คุณเปิดคอมพิวเตอร์ขึ้นมา เปิดโปรแกรมเขียนโค้ด (Text Editor) แล้วก็พบกับหน้ากระดาษว่างๆ พร้อมกับเคอร์เซอร์ที่กระพริบอยู่ตรงหน้า ในหัวคุณมี "โจทย์" ที่ต้องทำ แต่คุณไม่รู้ว่าจะเริ่มต้นเขียนโค้ดบรรทัดแรกอย่างไรดี ความรู้สึกว่างเปล่าและงุนงงนี้ ผมเชื่อว่าทุกคนเคยเจอ และมันคือสิ่งที่แยกระหว่างมือสมัครเล่นกับมืออาชีพ

วันนี้ผมจะมาบอกความลับให้ครับว่า ปัญหาของความรู้สึกนั้นไม่ได้อยู่ที่ว่าคุณ "เขียนโค้ดไม่เป็น" แต่อยู่ที่ว่าคุณยังไม่มี "กระบวนการในการแก้ปัญหา" ที่เป็นระบบต่างหาก

การเขียนโค้ดเป็นเพียงขั้นตอนสุดท้ายของการเดินทางอันยาวไกล ทักษะที่แท้จริงคือความสามารถในการนำทางจาก "จุดเริ่มต้น" ที่เป็นปัญหาอันคลุมเครือ ไปสู่ "จุดหมายปลายทาง" ที่เป็นโซลูชันที่ใช้งานได้จริง วันนี้เราจะมาสร้าง "แผนที่" หรือ "GPS" สำหรับการเดินทางนั้นกันครับ เราจะเปลี่ยนนิยามของ "โปรแกรมเมอร์" จาก "คนที่เขียนโค้ด" ไปเป็น "คนที่แก้ปัญหาโดยใช้โค้ดเป็นเครื่องมือ"

ส่วนที่ 1: กรอบการทำงาน 4 ขั้นตอนเพื่อพิชิตปัญหา (The 4-Step Problem-Solving Framework)
ไม่ว่าปัญหาจะเล็กเท่ากับการทำให้ไฟ LED ดวงหนึ่งกระพริบ หรือใหญ่เท่ากับการออกแบบระบบควบคุมทั้งคันของรถ Formula SAE EV เราสามารถใช้กรอบการทำงาน 4 ขั้นตอนที่เป็นสากลนี้ได้เสมอ

ขั้นตอนที่ 1: ทำความเข้าใจและแยกส่วนปัญหา (Understand & Deconstruct)
นี่คือขั้นตอนที่สำคัญที่สุด และเป็นขั้นตอนที่คนส่วนใหญ่มักจะมองข้ามเพราะใจร้อนอยากจะเริ่มเขียนโค้ด Albert Einstein เคยกล่าวไว้ว่า "ถ้าข้าพเจ้ามีเวลา 1 ชั่วโมงในการแก้ปัญหา ข้าพเจ้าจะใช้เวลา 55 นาทีในการคิดเกี่ยวกับปัญหา และอีก 5 นาทีในการคิดหาวิธีแก้"

การกระโจนเข้าไปเขียนโค้ดโดยที่ยังไม่เข้าใจปัญหาอย่างถ่องแท้ ก็เหมือนกับการออกเดินทางโดยไม่รู้ว่าจุดหมายปลายทางคือที่ไหน สิ่งที่คุณต้องทำในขั้นตอนนี้คือ:

พูดปัญหานั้นซ้ำด้วยคำพูดของตัวเอง: การที่คุณสามารถอธิบายปัญหาให้คนอื่น (หรือแม้แต่ตัวเอง) ฟังด้วยภาษาที่ง่ายๆ ได้ แสดงว่าคุณเริ่มเข้าใจมันแล้ว
ระบุ Input, Process, Output (IPO):
Input: เราต้องป้อนข้อมูลอะไรเข้าระบบบ้าง? (เช่น ค่าจากเซ็นเซอร์, คำสั่งจากผู้ใช้)
Process: เราต้องทำอะไรกับข้อมูลนั้น? (เช่น คำนวณ, เปรียบเทียบ, ตัดสินใจ)
Output: ผลลัพธ์สุดท้ายที่เราต้องการคืออะไร? (เช่น การแสดงผลบนจอ, การส่งคำสั่งไปที่มอเตอร์)
ถามคำถามให้เยอะที่สุด: อย่าเดา! ถ้ามีอะไรไม่ชัดเจนให้ถาม เช่น "ค่าจากเซ็นเซอร์นี้มีหน่วยเป็นอะไร?", "เงื่อนไขนี้ต้องเกิดขึ้นนานแค่ไหนถึงจะถือว่าผิดปกติ?"
ตัวอย่างในโลก FSAE:

ปัญหา: เราต้องควบคุมไฟ Tractive System Active Light (TSAL) ให้เป็นไปตามกฎ 
Deconstruction:
Input: แรงดันไฟฟ้าในระบบ Tractive System (TS)
Process: เปรียบเทียบแรงดันไฟฟ้ากับค่าเกณฑ์ (Threshold) ที่กฎกำหนด
Output: สถานะของไฟ TSAL (ติดค้าง หรือ ปิด)
คำถามที่ต้องถาม: ค่าเกณฑ์ของแรงดันไฟฟ้าคือเท่าไหร่? 60V DC ใช่หรือไม่? มีเงื่อนไขอื่นๆ อีกไหม?
ขั้นตอนที่ 2: วางแผนและออกแบบ (Plan & Design)
เมื่อเราเข้าใจปัญหาอย่างทะลุปรุโปร่งแล้ว ก็ถึงเวลาวาง "พิมพ์เขียว" หรือ "อัลกอริทึม" ครับ ในขั้นตอนนี้ เราจะยังไม่แตะโค้ดเลย แต่เราจะคิดถึง "วิธีทำ"

แก้ปัญหาง่ายๆ ก่อน: ถ้าปัญหามันซับซ้อน ลองคิดถึงเวอร์ชันที่ง่ายที่สุดของปัญหานั้นก่อน แล้วค่อยๆ เพิ่มความซับซ้อนเข้าไป
แบ่งปัญหาใหญ่ให้เป็นปัญหาย่อย (Top-Down Design): นี่คือเทคนิคที่ทรงพลังที่สุดเทคนิคหนึ่ง อย่าพยายามแก้ปัญหาทั้งก้อนในคราวเดียว แต่ให้ซอยมันออกเป็นส่วนเล็กๆ ที่จัดการได้ง่ายกว่า
เขียนแผนออกมา (Pseudocode / Flowchart): ใช้เครื่องมือที่เราเรียนไปในคาบที่แล้วเพื่อร่างอัลกอริทึมออกมาให้เห็นภาพชัดเจน
ตัวอย่างในโลก FSAE (ต่อจาก TSAL):

แผน (Pseudocode):
LOOP forever:
    voltage = read_TS_voltage_sensor()
    IF voltage > 60.0:
        turn_on_TSAL_light()
    ELSE:
        turn_off_TSAL_light()
    END IF
    delay(100_ms)
END LOOP
พิมพ์เขียวที่เรียบง่ายนี้คือหัวใจของโซลูชันทั้งหมดครับ
ขั้นตอนที่ 3: ลงมือทำและแปลเป็นโค้ด (Implement & Translate)
นี่คือขั้นตอนที่คนส่วนใหญ่เรียกว่า "การเขียนโปรแกรม" แต่ผมอยากให้มองว่ามันเป็นแค่ "การแปล" ครับ เรากำลังแปล "พิมพ์เขียว" ที่เราสร้างขึ้นในขั้นตอนที่ 2 ให้เป็นภาษาที่คอมพิวเตอร์เข้าใจ (เช่น ภาษา C)

ถ้าคุณทำขั้นตอนที่ 1 และ 2 มาเป็นอย่างดี ขั้นตอนนี้จะกลายเป็นขั้นตอนที่ตรงไปตรงมาที่สุด!

เขียนโค้ดที่สะท้อนแผนของคุณ: โครงสร้างของโค้ดควรจะล้อไปกับ Pseudocode ของคุณ
ใช้ชื่อตัวแปรที่สื่อความหมาย: tractive_system_voltage ดีกว่า v เสมอ เพราะมันช่วยให้โค้ดอ่านเข้าใจง่ายในอนาคต
ใส่คอมเมนต์เพื่ออธิบาย "ทำไม" ไม่ใช่ "อะไร":
คอมเมนต์ที่ไม่ดี: // add 1 to x (เสียเวลาอ่าน เพราะโค้ดมันก็บอกอยู่แล้ว)
คอมเมนต์ที่ดี: // Increment counter to track number of CAN message retries (อธิบายเจตนา)
ขั้นตอนที่ 4: ทบทวน, ทดสอบ, และปรับปรุง (Review, Test, & Refine)
ไม่มีโปรแกรมเมอร์คนไหนในโลกที่เขียนโค้ดสมบูรณ์แบบได้ในครั้งแรก การเขียนโปรแกรมเป็นกระบวนการที่ต้องทำซ้ำๆ (Iterative Process)

ทบทวนโค้ด (Code Review): อ่านโค้ดของตัวเองอีกครั้งหลังจากเขียนเสร็จ หรือให้เพื่อนในทีมช่วยดู มันเหมือนการพิสูจน์อักษรงานเขียนครับ มักจะเจอข้อผิดพลาดง่ายๆ ที่เรามองข้ามไปเสมอ
ทดสอบ, ทดสอบ, และทดสอบ!: นี่คือส่วนที่สำคัญอย่างยิ่งยวด
Happy Path Test: ทดสอบกรณีที่ทุกอย่างทำงานถูกต้องตามปกติ
Edge Case Test: ทดสอบกรณีที่เป็น "ขอบ" ของเงื่อนไข เช่น จะเกิดอะไรขึ้นถ้าแรงดันไฟฟ้าเท่ากับ 60.0V พอดีเป๊ะ?
Error Case Test: ทดสอบกรณีที่เกิดข้อผิดพลาด เช่น จะเกิดอะไรขึ้นถ้าเซ็นเซอร์เสียและส่งค่าติดลบมา? โปรแกรมของคุณจะพังหรือไม่?
ดีบัก (Debug): เมื่อเจอข้อผิดพลาด อย่ามองว่ามันคือความล้มเหลว ให้มองว่ามันคือ "ปริศนา" ที่ท้าทายให้เราสืบสวน การดีบักคือการทำงานของนักสืบเพื่อหาต้นตอของปัญหา
ปรับปรุง (Refine): เมื่อเจอจุดที่ต้องแก้ไข ก็กลับไปปรับปรุงแผนในขั้นตอนที่ 2 แล้วค่อยแก้โค้ดในขั้นตอนที่ 3 วนเป็นวงจรไปเรื่อยๆ จนกว่าจะได้โซลูชันที่แข็งแรงและน่าเชื่อถือ
ส่วนที่ 2: กรณีศึกษา - การออกแบบ Task หลักใน VCU
เรามาลองใช้กรอบการทำงาน 4 ขั้นตอนนี้กับปัญหาที่ซับซ้อนขึ้นกันดีกว่าครับ จากแผนการสอนของเรา VCU จะมี Task หนึ่งชื่อว่า Read_Sensors_Task  ซึ่งมีหน้าที่อ่านค่าจากคันเร่งและเบรก

ขั้นตอนที่ 1: ทำความเข้าใจและแยกส่วนปัญหา

เป้าหมาย: อ่านค่าจากเซ็นเซอร์คันเร่ง 2 ตัว (APPS1, APPS2) และเซ็นเซอร์เบรก 1 ตัว, ตรวจสอบความถูกต้องของข้อมูล, และส่งข้อมูลที่ "สะอาด" แล้วไปยัง Task อื่นๆ ผ่านคิว 
Input: ค่า ADC ดิบๆ จากเซ็นเซอร์ 3 ตัว
Output: เปอร์เซ็นต์คันเร่งสุดท้าย (0-100%) และสถานะการเบรก (เหยียบ/ไม่เหยียบ) ที่ถูกส่งเข้าคิว
เงื่อนไข/กฎ:
กฎของ FSAE กำหนดให้ต้องมีเซ็นเซอร์คันเร่ง 2 ตัวที่ทำงานแยกจากกัน และค่าของมันต้องสอดคล้องกัน (Plausibility Check) ถ้าค่าต่างกันเกิน 10% ต้องถือว่าผิดปกติและตัดกำลัง
ต้องมีการตรวจสอบการเหยียบเบรกและคันเร่งพร้อมกัน (BSPD Logic) 
ขั้นตอนที่ 2: วางแผนและออกแบบ (ใช้ Top-Down Design)
เราจะไม่แก้ปัญหาทั้งหมดในฟังก์ชันเดียว แต่จะซอยมันออกเป็นปัญหาย่อยๆ

สร้างฟังก์ชัน ReadRawValues(): ทำหน้าที่อ่านค่า ADC ดิบๆ จากเซ็นเซอร์ทั้ง 3 ตัว
สร้างฟังก์ชัน ValidateAcceleratorSensors(apps1_raw, apps2_raw):
แปลงค่าดิบของ APPS1 และ APPS2 เป็นเปอร์เซ็นต์
คำนวณผลต่างของทั้งสองค่า
IF ผลต่าง > 10% THEN return ERROR
ELSE return AVERAGE_PERCENTAGE
สร้างฟังก์ชัน CheckBrakeAndThrottle(brake_raw, final_throttle):
นำตรรกะของ BSPD มาใส่ในฟังก์ชันนี้
IF (เบรกถูกเหยียบ) AND (คันเร่งถูกเหยียบ) THEN return FAULT
ELSE return OK
ออกแบบตรรกะหลักของ Task:
เรียก ReadRawValues()
เรียก ValidateAcceleratorSensors()
ถ้าได้ค่า ERROR จากการ Validate -> ตั้งค่าคันเร่งเป็น 0 แล้วส่งสถานะ ERROR
ถ้าไม่ ERROR -> เรียก CheckBrakeAndThrottle()
ถ้าได้ค่า FAULT จากการเช็ค -> ตั้งค่าคันเร่งเป็น 0 แล้วส่งสถานะ ERROR
ถ้าทุกอย่างผ่าน -> นำค่าคันเร่งเฉลี่ยที่ได้ไปส่งเข้าคิว
ขั้นตอนที่ 3 และ 4 (Implementation & Testing)
จากแผนข้างบน เราจะเห็นว่าเราสามารถสร้างไฟล์ .c ที่มีฟังก์ชันย่อยๆ ที่ทดสอบได้ง่ายและเป็นอิสระต่อกัน เราสามารถเขียน Unit Test เพื่อทดสอบฟังก์ชัน ValidateAcceleratorSensors() แยกต่างหากได้ โดยการป้อนค่าที่ต่างกันเกิน 10% เข้าไป แล้วดูว่ามันคืนค่า ERROR ออกมาจริงหรือไม่ ซึ่งทำให้การพัฒนาและการบำรุงรักษาทำได้ง่ายกว่าการเขียนทุกอย่างรวมกันในฟังก์ชันเดียวมหาศาล

บทสรุป
การแก้ปัญหาคือทักษะที่อยู่เหนือภาษาโปรแกรม มันคือกระบวนการทางความคิดที่เป็นระบบและมีวินัย กรอบการทำงาน 4 ขั้นตอนที่เราเรียนกันในวันนี้ (Understand -> Plan -> Implement -> Review) คือเครื่องมือนำทางที่ทรงพลังที่สุดที่ผมจะมอบให้พวกคุณได้ มันคือสิ่งที่เปลี่ยนความรู้สึกว่า หน้าจอว่างเปล่า ให้กลายเป็นความรู้สึก "มั่นใจ" เพราะคุณมีแผนที่อยู่ในมือแล้ว

ผมอยากให้ทุกคนจำไว้ว่า เป้าหมายของเราไม่ใช่การเป็นคนที่พิมพ์โค้ดได้เร็วที่สุด แต่คือการเป็นคนที่สามารถสร้างโซลูชันที่ถูกต้อง, แข็งแรง, และน่าเชื่อถือที่สุด ซึ่งทั้งหมดนี้เริ่มต้นจากการมีกระบวนการแก้ปัญหาที่ดี

ดังนั้น จากนี้ไป เมื่อคุณได้รับโจทย์ใหม่ๆ อย่าเพิ่งรีบเปิดคอมพิวเตอร์ครับ แต่ให้หยิบกระดาษเปล่ากับปากกาขึ้นมา แล้วเริ่มต้นการเดินทาง 4 ขั้นตอนนี้... อย่าเพิ่งเขียนโค้ด แต่จงออกแบบโซลูชัน นี่แหละครับคือทักษะที่แท้จริงของโปรแกรมเมอร์และวิศวกรระดับโลก