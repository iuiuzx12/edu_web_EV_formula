"อัลกอริทึม" (Algorithm)

ผมเข้าใจดีว่าเมื่อได้ยินคำนี้ครั้งแรก หลายคนอาจจะรู้สึกว่ามันเป็นเรื่องที่ซับซ้อน เป็นคณิตศาสตร์ชั้นสูง หรือเป็นอะไรที่ไกลตัว แต่ในความเป็นจริงแล้ว ผมกล้ารับประกันเลยว่าพวกคุณทุกคนในที่นี้ ใช้อัลกอริทึมอยู่ทุกวัน โดยที่ไม่รู้ตัว

ตอนเช้าคุณต้มบะหมี่กึ่งสำเร็จรูปกิน... ขั้นตอนบนซองนั่นแหละครับ คือ อัลกอริทึม
คุณจะเดินทางจากหอพักมาที่มหาวิทยาลัย... เส้นทางที่คุณเลือกใน Google Maps นั่นก็คือผลลัพธ์จาก อัลกอริทึม
คุณประกอบเฟอร์นิเจอร์จาก IKEA... คู่มือการประกอบทีละขั้นตอนนั่นก็คือ อัลกอริทึม
ดังนั้น ขอให้ทุกคนวางความรู้สึกเกรงกลัวที่มีต่อคำนี้ลงก่อนนะครับ เพราะในคาบเรียนนี้ เราจะมา "ปอกเปลือก" แนวคิดของอัลกอริทึมให้เห็นถึงแก่นแท้ของมัน และที่สำคัญที่สุดคือ เราจะมาดูกันว่าแนวคิดนี้มันกลายมาเป็น "สมอง" ที่ขับเคลื่อนรถ Formula SAE EV ของเราได้อย่างไร

เป้าหมายของคาบเรียนนี้คือ:

นิยามและเข้าใจ คุณสมบัติของอัลกอริทึมที่ดี
เรียนรู้กระบวนการ ในการออกแบบอัลกอริทึมเพื่อแก้ปัญหา
เห็นตัวอย่างการประยุกต์ใช้ อัลกอริทึมจริงในระบบ VCU และ BMS ของรถแข่ง
ส่วนที่ 1: อัลกอริทึมคืออะไรกันแน่? (What is an Algorithm?)
ถ้าจะให้คำนิยามอย่างเป็นทางการ:

อัลกอริทึม คือ ชุดของขั้นตอนหรือคำสั่งที่ถูกกำหนดไว้อย่างชัดเจนและมีลำดับ เพื่อใช้ในการแก้ปัญหาหรือทำงานอย่างใดอย่างหนึ่งให้สำเร็จลุล่วง

มันก็คือ "สูตรอาหาร" หรือ "แผนการ" ที่มีรายละเอียดชัดเจนพอที่จะให้ใคร (หรืออะไร) ก็ตามทำตามแล้วได้ผลลัพธ์เหมือนกันทุกครั้ง

แต่อัลกอริทึมที่ดี ไม่ใช่แค่ชุดคำสั่งลอยๆ นะครับ มันจะต้องมีคุณสมบัติที่สำคัญ 5 ประการ ดังนี้:

มีข้อมูลเข้า (Input): ต้องรู้ว่าอัลกอริทึมต้องการข้อมูลอะไรเพื่อเริ่มต้นทำงาน (อาจจะมี 0 หรือหลายอินพุตก็ได้)

ตัวอย่างบะหมี่: อินพุตคือ บะหมี่ 1 ซอง, น้ำร้อน, ชาม
มีข้อมูลออก (Output): ต้องให้ผลลัพธ์อย่างน้อย 1 อย่างออกมาเมื่อทำงานเสร็จ

ตัวอย่างบะหมี่: เอาต์พุตคือ บะหมี่พร้อมทาน 1 ชาม
ต้องมีจุดสิ้นสุด (Finiteness): อัลกอริทึมต้องทำงานเสร็จสิ้นในจำนวนขั้นตอนที่จำกัด จะทำงานไปเรื่อยๆ ไม่รู้จบไม่ได้

ตัวอย่างบะหมี่: ขั้นตอนการต้มมีจุดสิ้นสุด ไม่ได้ต้มไปตลอดกาล
แต่ละขั้นตอนต้องชัดเจน ไม่กำกวม (Definiteness): ทุกคำสั่งต้องแม่นยำและเข้าใจได้ตรงกัน

คำสั่งที่ไม่ดี: "ใส่เครื่องปรุงตามชอบ" (แต่ละคนใส่ไม่เท่ากัน ผลลัพธ์ต่างกัน)
คำสั่งที่ดี: "ฉีกซองเครื่องปรุงทั้งหมดใส่ลงในชาม" (ทุกคนทำเหมือนกัน)
แต่ละขั้นตอนต้องสามารถทำได้จริง (Effectiveness): ทุกคำสั่งต้องเป็นสิ่งที่สามารถปฏิบัติได้

คำสั่งที่ไม่ดี: "คนส่วนผสมด้วยความเร็วเหนือเสียง" (ทำไม่ได้จริง)
คำสั่งที่ดี: "ใช้ตะเกียบคนส่วนผสมให้เข้ากันเป็นเวลา 30 วินาที" (ทำได้จริง)
เมื่อเราออกแบบ "แผนการ" ที่มีคุณสมบัติครบทั้ง 5 ข้อนี้ เราก็จะได้ "อัลกอริทึม" ที่ดีและน่าเชื่อถือ ซึ่งเป็นหัวใจสำคัญของการเขียนโปรแกรมคอมพิวเตอร์ครับ

ส่วนที่ 2: ศิลปะแห่งการแก้ปัญหา - การออกแบบอัลกอริทึม
พวกเราต้องเข้าใจก่อนว่า การเขียนโปรแกรมไม่ใช่การพิมพ์โค้ด แต่คือการแก้ปัญหา ไวยากรณ์ของภาษา C หรือภาษาอื่นๆ เป็นเพียง "เครื่องมือ" ที่เราใช้สื่อสารแผนการแก้ปัญหาของเรากับคอมพิวเตอร์เท่านั้น "ทักษะ" ที่แท้จริงของโปรแกรมเมอร์และวิศวกรคือ การออกแบบอัลกอริทึม ครับ

นี่คือเหตุผลสำคัญที่ในแผนการสอนของเราได้แนะนำให้เริ่มต้นด้วยหลักสูตรอย่าง CS50x ของฮาร์วาร์ด เพราะหลักสูตรนั้นสอน "ศิลปะแห่งการแก้ปัญหา" และ "การคิดเชิงอัลกอริทึม" นี้ก่อนที่จะลงมือเขียนโค้ดภาษา C เสียอีก 


แล้วกระบวนการออกแบบอัลกอริทึมนั้นมีหน้าตาเป็นอย่างไร? โดยทั่วไปแล้วเราจะทำตามขั้นตอนเหล่านี้:

ทำความเข้าใจปัญหา (Understand the Problem): นี่คือขั้นตอนที่สำคัญที่สุด! เราต้องถามตัวเองว่า:

เป้าหมายคืออะไร?
อินพุตคืออะไร? (ข้อมูลที่เรามี)
เอาต์พุตที่ต้องการคืออะไร? (ผลลัพธ์ที่เราอยากได้)
มีเงื่อนไขหรือข้อจำกัดอะไรบ้าง? (เช่น กฎของ FSAE, ข้อจำกัดของฮาร์ดแวร์)
วางแผนการแก้ปัญหา (Devise a Plan): ลองคิดหาวิธีแก้ปัญหาคร่าวๆ อาจจะวาดรูป หรือเขียนเป็นข้อๆ ยังไม่ต้องกังวลเรื่องโค้ด

ทำให้แผนเป็นทางการ (Formalize the Plan): เขียนแผนของเราออกมาในรูปแบบที่เป็นโครงสร้างมากขึ้น เพื่อให้เห็นลำดับขั้นตอนที่ชัดเจนและตรวจสอบความถูกต้องได้ง่าย เครื่องมือที่นิยมใช้กันมี 2 อย่างคือ:

รหัสเทียม (Pseudocode): คือการเขียนอธิบายอัลกอริทึมโดยใช้ภาษาอังกฤษ (หรือภาษาไทยก็ได้) ที่มีโครงสร้างคล้ายภาษาโปรแกรม (เช่น มี IF-ELSE, LOOP) เพื่อให้อ่านเข้าใจง่าย
ผังงาน (Flowchart): คือการใช้สัญลักษณ์รูปภาพต่างๆ แทนขั้นตอนการทำงานและใช้ลูกศรแสดงทิศทางการไหลของข้อมูล เหมาะสำหรับการแสดงภาพรวมของอัลกอริทึมที่ซับซ้อน
ลงมือเขียนโค้ด (Implement): แปลง Pseudocode หรือ Flowchart ของเราให้เป็นโค้ดในภาษาโปรแกรมที่เราเลือก (เช่น ภาษา C)

ทดสอบและปรับปรุง (Test and Refine): ตรวจสอบว่าโปรแกรมทำงานได้ถูกต้องตามที่คาดหวังหรือไม่? มันจัดการกับกรณีผิดพลาด (Error cases) หรือข้อมูลแปลกๆ (Edge cases) ได้หรือไม่? ถ้าไม่ ก็กลับไปปรับปรุงอัลกอริทึมของเราใหม่

กระบวนการนี้คือวงจรการทำงานของโปรแกรมเมอร์ทุกคนครับ

ส่วนที่ 3: อัลกอริทึมในสนามแข่ง - สมองของรถ FSAE
ทีนี้ เรามาดูตัวอย่างที่เป็นรูปธรรมกันดีกว่าครับ ว่า "สมอง" หรือหน่วยควบคุมยานพาหนะ (VCU) ของรถเรานั้นใช้อัลกอริทึมในการตัดสินใจอย่างไร

กรณีศึกษาที่ 1: อัลกอริทึมของ Brake System Plausibility Device (BSPD)
ตามกฎของ FSAE รถจะต้องมีระบบความปลอดภัยที่เรียกว่า BSPD ซึ่งมีหน้าที่ตัดกำลังของมอเตอร์ หากตรวจพบว่าคนขับกำลัง "เหยียบเบรก" และ "เหยียบคันเร่ง" พร้อมกันเป็นระยะเวลานานเกินกว่าที่กำหนด 

เราจะออกแบบอัลกอริทึมสำหรับฟังก์ชันนี้ได้อย่างไร?

ทำความเข้าใจปัญหา:

เป้าหมาย: ตัดกำลังมอเตอร์เพื่อความปลอดภัย
อินพุต: ค่าจากเซ็นเซอร์แรงดันเบรก, ค่าจากเซ็นเซอร์ตำแหน่งคันเร่ง
เอาต์พุต: สัญญาณ "ตัดกำลังมอเตอร์"
เงื่อนไข: เกิดขึ้นเมื่อ (เบรกถูกเหยียบเกินค่าที่กำหนด) และ (คันเร่งถูกเหยียบเกินค่าที่กำหนด) และ (เกิดขึ้นต่อเนื่องนานกว่า 500 มิลลิวินาที)
ออกแบบอัลกอริทึมด้วย Pseudocode:

LOOP forever:
    // อ่านค่าจากอินพุต
    brake_value = readBrakeSensor()
    throttle_value = readThrottleSensor()

    // ตรวจสอบเงื่อนไขการเกิด Plausibility Fault
    IF (brake_value > BRAKE_THRESHOLD) AND (throttle_value > THROTTLE_THRESHOLD):
        // ถ้าเงื่อนไขเป็นจริง ให้เริ่มจับเวลาหรือนับเวลาต่อ
        startOrContinue_PlausibilityTimer()
    ELSE:
        // ถ้าเงื่อนไขไม่เป็นจริง ให้รีเซ็ตเวลา
        reset_PlausibilityTimer()
    END IF

    // ตรวจสอบว่าจับเวลาครบกำหนดหรือยัง
    IF get_PlausibilityTimerValue() > 500_ms:
        // ถ้าครบแล้ว ให้ส่งสัญญาณตัดกำลัง
        set_motor_power(OFF)
    ELSE:
        // ถ้ายังไม่ครบ ก็ให้ทำงานตามปกติ
        set_motor_power(NORMAL)
    END IF

    // หน่วงเวลาเล็กน้อยก่อนเริ่มรอบใหม่
    delay(10_ms)
END LOOP
นี่คือตัวอย่างของอัลกอริทึมที่ชัดเจนและไม่กำกวม ซึ่งเป็นหัวใจของฟังก์ชันความปลอดภัยที่สำคัญในรถของเราครับ

กรณีศึกษาที่ 2: อัลกอริทึมหลักของ VCU (Control_Logic_Task)
ในแผนการสอนของเราได้อธิบายสถาปัตยกรรมของ VCU ที่ใช้ RTOS ซึ่งจะแบ่งงานออกเป็น Task ย่อยๆ  Task ที่เป็นหัวใจหลักคือ Control_Logic_Task  ซึ่งก็คืออัลกอริทึมที่ซับซ้อนขึ้นมาอีกระดับหนึ่ง


ทำความเข้าใจปัญหา:

เป้าหมาย: คำนวณ "แรงบิด" (Torque) ที่เหมาะสมที่สุดเพื่อส่งไปสั่งงานมอเตอร์
อินพุต:
ข้อมูลจากผู้ขับขี่ (ตำแหน่งคันเร่ง, แรงดันเบรก) ที่ถูกประมวลผลและส่งมาจาก Read_Sensors_Task ผ่านคิว 
ข้อมูลสถานะของรถ (ความเร็ว, อุณหภูมิแบตเตอรี่, สถานะ BMS) ที่ส่งมาจาก CAN_Receive_Task ผ่านคิว 
เอาต์พุต: คำสั่งแรงบิดสุดท้าย ที่จะถูกส่งไปยัง CAN_Transmit_Task เพื่อส่งออกไป 
อัลกอริทึมอย่างย่อ (Conceptual Algorithm):

LOOP forever:
    // 1. รอรับข้อมูลใหม่จากผู้ขับขี่และจาก CAN bus
    waitForNewData(from_driver_queue, from_can_queue)

    // 2. ตรวจสอบสถานะความปลอดภัยของระบบโดยรวม
    //    (เช่น BMS รายงานว่าแบตเตอรี่ร้อนเกินไปหรือไม่?)
    IF isSystemSafe(can_data) == FALSE:
        commanded_torque = 0  // สั่งตัดกำลังทันที
    ELSE:
        // 3. ถ้าปลอดภัยดี ให้คำนวณแรงบิดตามปกติ
        // 3.1 แปลงตำแหน่งคันเร่งของผู้ขับขี่เป็นค่าแรงบิดพื้นฐาน (Torque Mapping)
        base_torque = calculateTorqueFromThrottle(driver_data.throttle)

        // 3.2 ปรับแก้แรงบิดตามโหมดการขับขี่ (เช่น Eco Mode, Sport Mode)
        mode_adjusted_torque = adjustForDrivingMode(base_torque)

        // 3.3 ปรับแก้แรงบิดด้วยระบบขั้นสูง (เช่น Traction Control)
        //    (ลดแรงบิดถ้าล้อเริ่มหมุนฟรี)
        final_torque = applyTractionControl(mode_adjusted_torque, can_data.wheel_speed)

        commanded_torque = final_torque
    END IF

    // 4. ส่งผลลัพธ์สุดท้ายไปยังคิวสำหรับส่งออก
    sendToQueue(can_transmit_queue, commanded_torque)
END LOOP
จะเห็นได้ว่าซอฟต์แวร์ที่ซับซ้อนของ VCU นั้น แท้จริงแล้วก็คือการนำอัลกอริทึมย่อยๆ หลายๆ อัน (การอ่านเซ็นเซอร์, การตรวจสอบความปลอดภัย, การคำนวณแรงบิด) มาประกอบร่างกันทำงานอย่างเป็นระบบนั่นเองครับ

บทสรุป
วันนี้เราได้เรียนรู้ว่า "อัลกอริทึม" ไม่ใช่เรื่องน่ากลัว แต่เป็นเพียง "แผนการแก้ปัญหา" ที่มีขั้นตอนชัดเจนและมีลำดับ ซึ่งเป็นสิ่งที่พวกเราใช้กันอยู่แล้วในชีวิตประจำวัน เราได้เห็นคุณสมบัติ 5 ประการของอัลกอริทึมที่ดี และได้เรียนรู้กระบวนการออกแบบอัลกอริทึมตั้งแต่การทำความเข้าใจปัญหาไปจนถึงการทดสอบ

ที่สำคัญที่สุด เราได้เห็นว่าทุกการตัดสินใจของรถแข่ง EV ของเรา ตั้งแต่ฟังก์ชันความปลอดภัยพื้นฐานอย่าง BSPD ไปจนถึงการคำนวณแรงบิดที่ซับซ้อนของ VCU ล้วนขับเคลื่อนด้วย "อัลกอริทึม" ที่เราในฐานะวิศวกรเป็นผู้ออกแบบขึ้นมาทั้งสิ้น

ดังนั้น ผมอยากจะฝากกรอบความคิดใหม่นี้ไว้กับทุกคนครับ: เมื่อไหร่ก็ตามที่คุณเจอปัญหาทางการเขียนโปรแกรม อย่าเพิ่งถามตัวเองว่า "จะเขียนโค้ดอย่างไร?" แต่ให้ถามว่า "อัลกอริทึมในการแก้ปัญหานี้คืออะไร?" ก่อนเสมอ

เมื่อเรามี "พิมพ์เขียว" หรืออัลกอริทึมที่ชัดเจนและแข็งแรงแล้ว การจะแปลพิมพ์เขียวนั้นให้เป็นโค้ดภาษา C หรือภาษาใดๆ ก็ตาม จะกลายเป็นขั้นตอนที่ตรงไปตรงมาและง่ายขึ้นอย่างมหาศาลครับ