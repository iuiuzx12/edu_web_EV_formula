หลายคนอาจจะเคยได้ยินคำเหล่านี้ผ่านหูมาบ้าง อาจจะจากสเปคคอมพิวเตอร์หรือความเร็วอินเทอร์เน็ต แต่วันนี้ เราจะไม่ได้แค่ "รู้จัก" มัน แต่เราจะ "เข้าใจ" มันอย่างถ่องแท้ เพราะสำหรับวิศวกร Formula SAE EV อย่างพวกคุณ การไม่เข้าใจบิตและไบต์ก็เปรียบเสมือนนักแข่งรถที่ไม่เข้าใจว่าเครื่องยนต์ทำงานอย่างไร มันอาจจะขับได้ แต่ไม่มีทางดึงศักยภาพสูงสุดออกมาได้ และที่สำคัญคือ เมื่อเกิดปัญหา คุณจะไม่สามารถวิเคราะห์และแก้ไขที่ต้นตอได้เลย

คาบเรียนนี้เราจะมาตอบคำถามสำคัญ 3 ข้อด้วยกัน:

อะไรคือบิตและไบต์? - เราจะทำความรู้จักกับหน่วยที่เล็กที่สุดของข้อมูล
มันทำงานอย่างไร? - ทำไมคอมพิวเตอร์ถึงเลือกใช้ระบบนี้ และมันสร้างข้อมูลที่ซับซ้อนขึ้นมาได้อย่างไร
ทำไมมันถึงสำคัญอย่างยิ่งยวดต่องานของเรา? - เราจะเชื่อมโยงความรู้พื้นฐานนี้เข้ากับการควบคุมไมโครคอนโทรลเลอร์ในรถแข่ง EV ของเราโดยตรง
เอาล่ะครับ มาเริ่มกันที่หน่วยที่เล็กที่สุดกันก่อน

ส่วนที่ 1: บิต (Bit) - อะตอมแห่งโลกดิจิทัล
ลองจินตนาการตามผมนะครับ ลองนึกถึงสวิตช์ไฟธรรมดาๆ ในห้องของเรา มันมีสถานะที่เป็นไปได้กี่อย่างครับ? ... ใช่แล้วครับ มีแค่ 2 อย่าง คือ "เปิด" กับ "ปิด" เท่านั้น ไม่มีสถานะ "เปิดครึ่งๆ" หรือ "หรี่ๆ" (นั่นคือโลกของอนาล็อกที่เราจะไม่พูดถึงวันนี้)

"บิต" ก็คือสวิตช์ไฟตัวนั้นในโลกดิจิทัลครับ

บิต (Bit) ย่อมาจาก Binary Digit ซึ่งแปลตรงตัวว่า "ตัวเลขฐานสอง" มันคือหน่วยข้อมูลที่เล็กที่สุดที่คอมพิวเตอร์สามารถจัดการได้ และมันมีค่าที่เป็นไปได้เพียง 2 สถานะเท่านั้น คือ:

0 (เปรียบเหมือนสวิตช์ "ปิด", ไม่มีกระแสไฟ, สถานะ Low)
1 (เปรียบเหมือนสวิตช์ "เปิด", มีกระแสไฟ, สถานะ High)
คำถามคือ: ทำไมต้องเป็น 0 กับ 1? ทำไมไม่ใช้ 0-9 เหมือนที่เราคุ้นเคย?

คำตอบอยู่ที่ธรรมชาติของอุปกรณ์อิเล็กทรอนิกส์ครับ การสร้างวงจรที่สามารถแยกแยะสถานะ "มีไฟ" กับ "ไม่มีไฟ" ได้อย่างชัดเจนและน่าเชื่อถือนั้นทำได้ง่ายและต้นทุนถูกกว่าการสร้างวงจรที่ต้องแยกแยะระดับแรงดันไฟฟ้า 10 ระดับอย่างแม่นยำมากๆ ในทางกายภาพ บิต 1 บิต ก็คือทรานซิสเตอร์ตัวจิ๋วๆ 1 ตัวที่ทำหน้าที่เป็นสวิตช์เปิด-ปิดนั่นเอง การใช้ระบบฐานสองจึงทำให้การออกแบบฮาร์ดแวร์มีความเสถียร ทนทานต่อสัญญาณรบกวน และทำงานได้อย่างรวดเร็วครับ

แต่... บิตเพียงตัวเดียวมันทำอะไรได้ไม่มากนักใช่ไหมครับ? เราบอกได้แค่ ใช่/ไม่ใช่, จริง/เท็จ, เปิด/ปิด มันยังไม่สามารถใช้แทนข้อมูลที่ซับซ้อนอย่างตัวอักษรหรือตัวเลขจำนวนมากๆ ได้ นั่นจึงนำเราไปสู่ส่วนต่อไป

ส่วนที่ 2: ไบต์ (Byte) - การรวมพลังเพื่อสร้างความหมาย
เมื่อบิตเดียวไม่พอ เราก็แค่เอามันมาเรียงต่อกันเป็นกลุ่มครับ เหมือนกับการนำตัวอักษรมาเรียงต่อกันให้เป็น "คำ" ในโลกคอมพิวเตอร์ กลุ่มของบิตที่ได้รับการยอมรับเป็นมาตรฐานสากลและใช้กันอย่างแพร่หลายที่สุดก็คือ "ไบต์" (Byte)

1 ไบต์ (Byte) = 8 บิต (Bits)

ทีนี้ล่ะครับ ความมหัศจรรย์เริ่มบังเกิด เมื่อเรามีสวิตช์ไฟ 8 ตัวเรียงกัน เราจะสามารถสร้างรูปแบบการเปิด-ปิดที่แตกต่างกันได้กี่แบบ?

ถ้ามี 1 บิต (สวิตช์ 1 ตัว) เรามี 2 รูปแบบ: 0, 1
ถ้ามี 2 บิต (สวิตช์ 2 ตัว) เรามี 4 รูปแบบ: 00, 01, 10, 11
ถ้ามี 3 บิต (สวิตช์ 3 ตัว) เรามี 8 รูปแบบ: 000, 001, 010, 011, 100, 101, 110, 111
สังเกตเห็นรูปแบบทางคณิตศาสตร์ไหมครับ? จำนวนรูปแบบที่เป็นไปได้คือ 2 
n
  โดยที่ n คือจำนวนบิต

ดังนั้น เมื่อเรามี 8 บิตใน 1 ไบต์ เราจะมีรูปแบบที่แตกต่างกันได้ทั้งหมด 2 
8
 =256 รูปแบบ!
ตั้งแต่ 00000000 ไปจนถึง 11111111

แล้ว 256 รูปแบบนี้เอาไปทำอะไรได้?

เราในฐานะโปรแกรมเมอร์และวิศวกร สามารถ "ตกลง" กันได้ว่าแต่ละรูปแบบจะใช้แทนความหมายอะไร นี่คือหัวใจสำคัญครับ รูปแบบบิตเองไม่มีความหมาย จนกว่าเราจะให้ความหมายกับมันผ่านสิ่งที่เรียกว่า "การเข้ารหัส" (Encoding)

การแทนตัวเลข: เราสามารถใช้ 256 รูปแบบนี้เพื่อแทนตัวเลขจำนวนเต็มได้ตั้งแต่ 0 (00000000) ไปจนถึง 255 (11111111) นี่คือพื้นฐานของชนิดข้อมูลแบบ unsigned char หรือ uint8_t ในภาษา C

การแทนตัวอักษร: เรามีมาตรฐานสากลที่ชื่อว่า ASCII (American Standard Code for Information Interchange) ซึ่งกำหนดว่ารูปแบบบิตแบบไหนจะแทนตัวอักษร, ตัวเลข, หรือสัญลักษณ์อะไร

เช่น รูปแบบ 01000001 (หรือเลข 65 ในฐานสิบ) ถูกกำหนดให้หมายถึงตัวอักษร 'A'
รูปแบบ 01000010 (หรือเลข 66 ในฐานสิบ) ถูกกำหนดให้หมายถึงตัวอักษร 'B'
รูปแบบ 00110001 (หรือเลข 49 ในฐานสิบ) ถูกกำหนดให้หมายถึงตัวอักษร '1'
ดังนั้น ทุกครั้งที่คุณพิมพ์คีย์บอร์ด สิ่งที่คอมพิวเตอร์รับเข้าไปจริงๆ ไม่ใช่ตัวอักษร แต่เป็นชุดของบิตและไบต์ตามมาตรฐานนี้นั่นเองครับ

ส่วนที่ 3: การประยุกต์ใช้จริงสำหรับวิศวกร FSAE
เอาล่ะครับ ถึงช่วงที่สำคัญที่สุดแล้ว ทำไมทั้งหมดที่ผมพูดมาถึงสำคัญกับคนที่กำลังจะสร้างรถแข่ง EV?

1. การควบคุมฮาร์ดแวร์โดยตรงผ่าน "รีจิสเตอร์" (Registers)
ไมโครคอนโทรลเลอร์ (MCU) อย่าง STM32 ที่พวกเราใช้กันเป็นหลักในวงการ FSAE  มันคือสมองของรถ  การจะสั่งให้ MCU ทำงาน ไม่ว่าจะเป็นการเปิดไฟ LED, อ่านค่าจากเซ็นเซอร์คันเร่ง, หรือส่งข้อมูลผ่าน CAN bus เราไม่ได้สั่งมันด้วยคำพูดสวยหรูครับ แต่เราทำโดยการ "เขียนค่าบิต" ลงไปในตำแหน่งหน่วยความจำพิเศษที่เรียกว่า "รีจิสเตอร์" (Hardware Registers) 




ลองนึกภาพตามนะครับ:

MCU อาจจะมีรีจิสเตอร์ตัวหนึ่งชื่อว่า GPIOA_ODR ขนาด 32 บิต สำหรับควบคุมการเปิด-ปิดขา I/O ของพอร์ต A ทั้ง 32 ขา
ถ้าขาที่ 5 (Bit 5) ของพอร์ตนี้ต่ออยู่กับไฟ LED บนแดชบอร์ด
การที่เราจะสั่งให้ไฟดวงนี้ติด เราต้องเข้าไปเปลี่ยนค่า บิตที่ 5 ของรีจิสเตอร์ GPIOA_ODR ให้เป็น 1
และที่สำคัญคือ เราต้องทำสิ่งนี้ โดยไม่ไปกระทบกับค่าของบิตอื่นๆ อีก 31 บิตที่อาจจะกำลังควบคุมอุปกรณ์อื่นอยู่!
นี่คือเหตุผลว่าทำไมเราต้องเรียนเรื่อง Bitwise Operations (AND, OR, XOR, SHIFT) ในบทเรียนถัดๆ ไป  เพราะมันคือเครื่องมือที่ช่วยให้เราสามารถเข้าไปจัดการบิตแต่ละตัวในไบต์หรือในเวิร์ด (Word) ได้อย่างแม่นยำ การควบคุมฮาร์ดแวร์ในระดับล่างคือการเขียน-อ่านบิตในรีจิสเตอร์นั่นเองครับ 


2. การใช้หน่วยความจำ (RAM) อย่างมีประสิทธิภาพสูงสุด
แตกต่างจากคอมพิวเตอร์ทั่วไปที่อาจมี RAM 16 หรือ 32 กิกะไบต์, MCU ของเรามีทรัพยากรที่จำกัดมาก อาจจะมี SRAM แค่ไม่กี่ร้อยกิโลไบต์เท่านั้น  ดังนั้น ทุกๆ ไบต์จึงมีค่ามหาศาล

สมมติว่าคุณกำลังอ่านค่าอุณหภูมิของแบตเตอรี่ ซึ่งมีค่าอยู่ในช่วง 0 - 150 องศาเซลเซียส

ตัวเลข 150 สามารถจัดเก็บใน 1 ไบต์ (8 บิต) ได้สบายๆ เพราะ 1 ไบต์เก็บค่าได้ถึง 255
ถ้าคุณประกาศตัวแปรในภาษา C โดยใช้ชนิดข้อมูล int ซึ่งใน MCU ตระกูล ARM มักจะมีขนาด 4 ไบต์ (32 บิต) เพื่อเก็บค่าอุณหภูมินี้ นั่นหมายความว่าคุณกำลัง สิ้นเปลืองหน่วยความจำไป 3 ไบต์โดยไม่จำเป็น สำหรับทุกๆ ตัวแปรอุณหภูมิที่คุณสร้าง!
อาจจะฟังดูไม่เยอะ แต่ถ้าคุณต้องเก็บข้อมูลอุณหภูมิของเซลล์แบตเตอรี่ 100 เซลล์ในอาร์เรย์ คุณจะเสียหน่วยความจำไปเปล่าๆ ถึง 300 ไบต์ ซึ่งอาจเป็นหน่วยความจำที่มีค่าสำหรับ Task อื่นๆ ของ RTOS ก็เป็นได้
การเลือกใช้ชนิดข้อมูลที่เล็กที่สุดที่เพียงพอต่องาน (เช่น uint8_t ที่มีขนาด 1 ไบต์) จึงเป็นทักษะที่สำคัญอย่างยิ่งสำหรับโปรแกรมเมอร์ระบบสมองกลฝังตัว เพื่อสงวน SRAM อันมีค่าไว้ 

3. การ "แพ็ค" และ "แกะ" ข้อมูลในการสื่อสาร
ระบบสื่อสารหลักในรถของเราคือ CAN bus  ซึ่งเป็นระบบที่ส่ง "ข้อความ" (Messages) หากัน โครงสร้างข้อความของ CAN หนึ่งเฟรมนั้นมีส่วนของ "ข้อมูล" (Data Payload) ได้แค่ 0 ถึง 8 ไบต์เท่านั้น 


สมมติว่า VCU (Vehicle Control Unit) ต้องการส่งคำสั่งไปยังตัวควบคุมมอเตอร์ โดยในคำสั่งนั้นประกอบด้วย:

คำสั่งแรงบิด (Torque Command): สมมติว่ามีค่า 0 - 4000
สถานะ (Status): 4 สถานะ (เช่น Off, Forward, Reverse, Regen)
คำสั่งเปิด/ปิดพัดลม (Fan Command): เปิด หรือ ปิด
คุณจะส่งข้อมูล 3 อย่างนี้ไปใน 8 ไบต์ได้อย่างไร? คุณไม่สามารถส่งแยกข้อความกันได้เพราะจะเปลืองแบนด์วิดท์และอาจเกิดความล่าช้า
คำตอบคือการ "แพ็คข้อมูล" (Data Packing) ครับ คุณต้องออกแบบว่าจะเอาข้อมูลแต่ละส่วนไปยัดไว้ในบิตไหนของไบต์ไหนบ้าง

ค่าแรงบิด 4000 ต้องใช้กี่บิต? (2 
11
 =2048, 2 
12
 =4096 ดังนั้นต้องใช้ 12 บิต)
สถานะ 4 สถานะ ต้องใช้กี่บิต? (2 
2
 =4 ดังนั้นต้องใช้ 2 บิต)
คำสั่งพัดลม เปิด/ปิด ต้องใช้กี่บิต? (ใช้แค่ 1 บิต)
คุณอาจจะใช้ 2 ไบต์แรก (16 บิต) โดย 12 บิตแรกเก็บค่าแรงบิด, 2 บิตถัดมาเก็บสถานะ, 1 บิตถัดมาเก็บคำสั่งพัดลม และเหลืออีก 1 บิตไว้เฉยๆ หรือใช้เป็นแฟล็ก (Flag) อื่นๆ
เมื่อฝั่งรับ (ตัวควบคุมมอเตอร์) ได้รับ 2 ไบต์นี้มา มันก็ต้องรู้วิธี "แกะ" ข้อมูลกลับออกมาตามรูปแบบที่เราตกลงกันไว้

นี่คือโลกแห่งความเป็นจริงของการพัฒนาระบบสมองกลฝังตัวครับ เราต้องทำงานในระดับ "บิต" และ "ไบต์" อยู่ตลอดเวลา