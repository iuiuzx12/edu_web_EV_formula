ก่อนจะเริ่ม ผมอยากถามอะไรหน่อย... ทำไมในชีวิตประจำวันเราถึงใช้ "เลขฐานสิบ" ครับ? ทำไมเราถึงนับ 1, 2, 3... พอถึง 9 แล้วตัวต่อไปต้องขึ้นหลักใหม่เป็น 10? ... คำตอบนั้นง่ายกว่าที่คิดครับ เพราะเรามี สิบนิ้ว นั่นเอง! ระบบเลขฐานสิบจึงเป็นระบบที่ธรรมชาติที่สุดสำหรับมนุษย์

แต่คอมพิวเตอร์ที่เกิดจากสวิตช์เปิด-ปิด มันไม่ได้มีสิบนิ้วแบบเรา มันมีแค่สองสถานะคือ 0 กับ 1 ดังนั้น "ภาษา" หรือระบบตัวเลขที่มันเข้าใจโดยธรรมชาติจึงแตกต่างจากเราโดยสิ้นเชิง

ในฐานะวิศวกรและโปรแกรมเมอร์ที่ต้องทำงานเชื่อมต่อระหว่างโลกมนุษย์กับโลกของเครื่องจักร เราจึงจำเป็นต้องเป็นเหมือน "นักแปล" ที่สามารถพูดได้หลายภาษา วันนี้เราจะมาเรียนรู้ 3 ภาษาหลักที่จำเป็นอย่างยิ่งยวด ได้แก่:

เลขฐานสิบ (Decimal): ภาษาที่เราใช้กันในชีวิตประจำวัน
เลขฐานสอง (Binary): ภาษาแม่ของคอมพิวเตอร์
เลขฐานสิบหก (Hexadecimal): ภาษาของโปรแกรมเมอร์ ที่เป็นสะพานเชื่อมระหว่างสองโลก
เป้าหมายของคาบเรียนนี้ ไม่ใช่แค่ให้พวกคุณ "คำนวณ" เลขฐานต่างๆ ได้ แต่เพื่อให้ "เข้าใจ" ว่าทำไมเราถึงต้องมีมัน และมันถูกนำไปใช้จริงในการพัฒนารถ Formula SAE EV ของเราอย่างไร

ส่วนที่ 1: ทบทวนภาษาของเรา - เลขฐานสิบ (Decimal / Base-10)
ก่อนจะไปเรียนภาษาใหม่ เรามาทบทวนโครงสร้างภาษาแม่ของเราให้เข้าใจอย่างถ่องแท้กันก่อนครับ

เมื่อเราเห็นตัวเลขอย่าง 357 เราไม่ได้อ่านว่า "สาม ห้า เจ็ด" ใช่ไหมครับ? ในใจเราจะรู้ทันทีว่ามันคือ "สามร้อยห้าสิบเจ็ด" ความหมายนี้เกิดขึ้นจากสิ่งที่เรียกว่า "ค่าประจำหลัก" (Place Value)

7 อยู่ในหลักหน่วย (10 
0
 ) มีค่าเท่ากับ 7×1=7
5 อยู่ในหลักสิบ (10 
1
 ) มีค่าเท่ากับ 5×10=50
3 อยู่ในหลักร้อย (10 
2
 ) มีค่าเท่ากับ 3×100=300
ดังนั้น ค่าของ 357 จริงๆ แล้วก็คือผลรวมของ (3×10 
2
 )+(5×10 
1
 )+(7×10 
0
 )

นี่คือหัวใจของระบบเลขฐานครับ: ค่าของตัวเลขทั้งหมด คือผลรวมของ (ตัวเลขในหลักนั้น × ค่าประจำหลักนั้น)
ขอให้ทุกคนจำ "แม่แบบ" หรือ "Template" นี้ไว้ให้ดีนะครับ เพราะเราจะใช้มันกับทุกๆ ฐานที่เราจะเรียนกันในวันนี้

ส่วนที่ 2: ภาษาของคอมพิวเตอร์ - เลขฐานสอง (Binary / Base-2)
อย่างที่เกริ่นไป คอมพิวเตอร์ทำงานกับบิต (0 และ 1) ดังนั้นระบบเลขของมันจึงมีตัวเลขแค่ 2 ตัว คือ 0 กับ 1 เท่านั้น แล้วมันจะนับเลขที่มากกว่า 1 ได้อย่างไร?

คำตอบคือ... มันใช้ "แม่แบบ" เดียวกับเลขฐานสิบเป๊ะๆ เลยครับ! เพียงแค่เปลี่ยน "ฐาน" จาก 10 เป็น 2

ค่าประจำหลักของเลขฐานสองจึงไม่ใช่ 10 
0
 ,10 
1
 ,10 
2
 ,... แต่เป็น:

หลักที่ 1: 2 
0
 =1
หลักที่ 2: 2 
1
 =2
หลักที่ 3: 2 
2
 =4
หลักที่ 4: 2 
3
 =8
หลักที่ 5: 2 
4
 =16
...และต่อไปเรื่อยๆ
ลองมาแปลเลขฐานสองเป็นฐานสิบกันดูครับ
สมมติเราเจอเลขฐานสอง 1101₂ (ตัวห้อย ₂ หมายถึงเป็นเลขฐานสอง) เราจะแปลโดยใช้แม่แบบของเรา:
1101₂ = (1×2 
3
 )+(1×2 
2
 )+(0×2 
1
 )+(1×2 
0
 )
= (1×8)+(1×4)+(0×2)+(1×1)
= 8+4+0+1=13 
10
​
  (ตัวห้อย ₁₀ หมายถึงเป็นเลขฐานสิบ)

เห็นไหมครับว่ามันคือตรรกะเดียวกันเป๊ะๆ เลย

แล้วถ้าจะแปลกลับจากฐานสิบเป็นฐานสองล่ะ?
เราจะใช้วิธี "การหารด้วย 2 แล้วเก็บเศษ" ครับ
สมมติเราต้องการแปลง 13 
10
​
  เป็นฐานสอง:

13÷2=6 เศษ 1 (นี่คือบิตขวาสุด หรือ Bit 0)
6÷2=3 เศษ 0
3÷2=1 เศษ 1
1÷2=0 เศษ 1 (นี่คือบิตซ้ายสุด หรือ Bit 3)
เมื่อผลหารเป็น 0 ก็หยุด แล้วนำเศษที่ได้มาอ่าน "จากล่างขึ้นบน" เราจะได้ 1101₂ ซึ่งตรงกับที่เราคำนวณไว้ตอนแรกพอดี

ปัญหาของเลขฐานสอง:
เลขฐานสองนั้นเป็นภาษาที่คอมพิวเตอร์เข้าใจได้ดีเยี่ยม แต่สำหรับมนุษย์ มันยาวและอ่านยากมากครับ
ลองนึกภาพว่าถ้าคุณต้องอ่านค่าจากรีจิสเตอร์ขนาด 16 บิต แล้วเห็นค่าเป็น 1011101001011100... แค่พยายามอ่านให้ถูกก็ปวดหัวแล้วใช่ไหมครับ?

นั่นจึงเป็นที่มาของ "ภาษาสะพาน" ที่เราจะเรียนกันต่อไป

ส่วนที่ 3: ภาษาของโปรแกรมเมอร์ - เลขฐานสิบหก (Hexadecimal / Base-16)
เพื่อแก้ปัญหาความยาวและอ่านยากของเลขฐานสอง โปรแกรมเมอร์และวิศวกรจึงนิยมใช้ เลขฐานสิบหก (Hexadecimal หรือเรียกสั้นๆ ว่า "Hex") เป็นอย่างมาก

Hexadecimal คือ "ตัวย่อ" ของ Binary นั่นเองครับ

ระบบนี้มีเลข 16 ตัว แต่เรามีสัญลักษณ์ตัวเลขแค่ 0-9 เราจึงยืมตัวอักษร A-F มาใช้แทนค่าที่มากกว่า 9 ดังนี้:

0-9 แทนค่า 0-9
A แทนค่า 10
B แทนค่า 11
C แทนค่า 12
D แทนค่า 13
E แทนค่า 14
F แทนค่า 15
ความมหัศจรรย์ของเลขฐานสิบหกอยู่ตรงนี้ครับ:
ค่า 16 นั้นเท่ากับ 2 
4
  พอดีเป๊ะ! ความสัมพันธ์ทางคณิตศาสตร์นี้ทำให้ เลขฐานสิบหก 1 หลัก สามารถแทนเลขฐานสองได้ 4 หลัก (4 บิต) พอดิบพอดี นี่คือเหตุผลทั้งหมดที่ทำให้มันมีประโยชน์อย่างมหาศาล

Hex	Binary	Decimal
0	0000	0
1	0001	1
...	...	...
9	1001	9
A	1010	10
B	1011	11
C	1100	12
D	1101	13
E	1110	14
F	1111	15

ส่งออกไปยังชีต
ทีนี้ ลองกลับมาดูเลขฐานสองที่น่าปวดหัวจากตัวอย่างที่แล้วกัน: 1011101001011100
เราจะแปลงเป็นเลขฐานสิบหกโดยการ "จัดกลุ่มทีละ 4 บิต" จากขวามาซ้าย:

1011 | 1010 | 0101 | 1100

จากนั้นก็แค่แปลทีละกลุ่มตามตาราง:

1011 คือ B
1010 คือ A
0101 คือ 5
1100 คือ C
เมื่อนำมารวมกัน เราจะได้เป็น BA5C₁₆ ซึ่งสั้น กระชับ อ่านง่าย และสื่อสารผิดพลาดได้ยากกว่าเลขฐานสองยาวๆ มาก ในภาษาโปรแกรมอย่าง C เราจะเขียนเลขฐานสิบหกโดยการเติม 0x เข้าไปข้างหน้า เช่น 0xBA5C เพื่อบอกให้คอมไพเลอร์รู้ว่านี่คือเลขฐานสิบหก

ส่วนที่ 4: การประยุกต์ใช้จริงในงานวิศวกรรมยานยนต์ FSAE
มาถึงส่วนที่สำคัญที่สุด: เราเรียนเรื่องทั้งหมดนี้ไปทำไม? มันเอาไปใช้ตรงไหนในรถของเรา?

1. ที่อยู่หน่วยความจำ (Memory Addresses)
ทุกสิ่งทุกอย่างใน MCU ของเรา ไม่ว่าจะเป็นโค้ดโปรแกรม, ตัวแปร, หรือรีจิสเตอร์ที่ใช้ควบคุมฮาร์ดแวร์ ล้วนถูกเก็บไว้ใน "หน่วยความจำ" (Memory) ซึ่งมี "บ้านเลขที่" หรือ "Address" กำกับไว้ทั้งหมด และ Address เหล่านี้ จะถูกแสดงในรูปของเลขฐานสิบหกเสมอ ในเอกสารคู่มือ (Datasheet), ในโปรแกรมดีบักเกอร์, และในโค้ดของเรา 

ตัวอย่างโค้ดที่อาจจะดูน่ากลัวในตอนแรก แต่ตอนนี้พวกคุณน่าจะเข้าใจมันดีขึ้น:
volatile GPIO_TypeDef *GPIOA = (GPIO_TypeDef *)0x40020000; 

โค้ดบรรทัดนี้กำลังบอกว่า "ช่วยสร้างตัวชี้ชื่อ GPIOA ให้ชี้ไปยังบ้านเลขที่ 0x40020000 ในหน่วยความจำหน่อย" ซึ่งตาม Datasheet ของชิป STM32F4 มันคือตำแหน่งเริ่มต้นของรีจิสเตอร์ที่ใช้ควบคุมพอร์ต I/O A ทั้งหมด ถ้าเราไม่เข้าใจเลขฐานสิบหก เราจะไม่มีทางรู้ได้เลยว่าโค้ดบรรทัดนี้กำลังทำอะไรอยู่

2. การอ่านค่าจากรีจิสเตอร์ของฮาร์ดแวร์
เมื่อเราใช้โปรแกรมดีบักเกอร์เพื่อตรวจสอบการทำงานของโปรแกรม เรามักจะต้องดูค่าในรีจิสเตอร์ต่างๆ เพื่อให้แน่ใจว่าเราได้ตั้งค่าฮาร์ดแวร์ถูกต้องหรือไม่ ค่าที่แสดงในดีบักเกอร์จะเป็นเลขฐานสิบหก

สมมติว่าคุณตั้งค่ารีจิสเตอร์ตัวหนึ่งให้เป็น 0x000000F0 คุณต้องสามารถแปลค่านี้ในใจกลับเป็นเลขฐานสองได้อย่างรวดเร็ว:
0x...F0 = ... 1111 0000
นี่ทำให้คุณรู้ทันทีว่า "โอเค บิตที่ 4, 5, 6, 7 ถูกตั้งค่าเป็น 1 ส่วนบิตที่ 0, 1, 2, 3 เป็น 0" ซึ่งช่วยให้การดีบักและการตรวจสอบความถูกต้องของฮาร์ดแวร์ทำได้อย่างรวดเร็ว

3. การสื่อสารข้อมูลผ่าน CAN Bus
อย่างที่เราทราบกันดีว่า CAN bus คือระบบประสาทของรถเรา  ข้อมูลที่วิ่งอยู่ใน CAN bus จะถูกส่งเป็น "เฟรม" (Frame) ซึ่งในแต่ละเฟรมจะมีรหัสระบุข้อความ (CAN ID) และข้อมูล (Data Payload) 0-8 ไบต์ 


เมื่อคุณใช้เครื่องมือวิเคราะห์ CAN (CAN Analyzer) เพื่อดูข้อมูลที่วิ่งอยู่ในรถ คุณจะเห็นข้อมูลหน้าตาแบบนี้:
ID: 0x1A8 Data: 0F 1B 00 FF C3 00 00 10

ID: 0x1A8 คือรหัสของข้อความนี้ในรูปเลขฐานสิบหก
Data: 0F 1B ... คือข้อมูล 8 ไบต์ ที่แสดงเป็นเลขฐานสิบหก
ถ้าคุณไม่เข้าใจเลขฐาน คุณจะไม่สามารถ "อ่าน" ข้อมูลเหล่านี้ได้เลย คุณจะไม่รู้ว่า 0F คือค่าอะไรที่ส่งมาจาก BMS หรือ FF C3 คือค่าแรงบิดที่ VCU กำลังส่งไปให้มอเตอร์

บทสรุป
ในคาบเรียนนี้ เราได้เดินทางผ่าน 3 โลกของตัวเลข:

ฐานสิบ: โลกของมนุษย์ ที่คุ้นเคยและเป็นธรรมชาติ
ฐานสอง: โลกของคอมพิวเตอร์ ที่ทำงานกับสถานะเปิด-ปิด
ฐานสิบหก: โลกของโปรแกรมเมอร์ ที่เป็นสะพานเชื่อม ทำให้เราสามารถอ่านและเขียนภาษาของคอมพิวเตอร์ได้อย่างมีประสิทธิภาพ
ความสามารถในการแปลงไปมาระหว่างฐานเหล่านี้ได้อย่างคล่องแคล่ว ไม่ใช่แค่ทักษะทางคณิตศาสตร์ แต่เป็น ทักษะพื้นฐานที่จำเป็นอย่างยิ่งยวด สำหรับวิศวกรระบบสมองกลฝังตัว มันคือแว่นตาที่ช่วยให้คุณมองเห็นสิ่งที่เกิดขึ้นจริงๆ ภายใต้โค้ดภาษา C ที่สวยงาม มันช่วยให้คุณอ่าน Datasheet ได้, ดีบักโปรแกรมได้, และออกแบบระบบสื่อสารได้อย่างถูกต้อง